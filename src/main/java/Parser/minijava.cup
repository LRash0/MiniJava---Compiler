/*
 * CUP specification for the parser for a simple demo language
 * Change this into the parser for your implementation of MiniJava.
 */

package Parser;

import Throwables.*;
import AST.*;
import java.util.*;
import java_cup.runtime.*;


/* Terminals (tokens returned by the scanner) */

/* reserved words: */

terminal WORD_RETURN;
terminal WORD_CLASS;
terminal WORD_PUBLIC;
terminal WORD_STATIC;
terminal WORD_VOID;
terminal WORD_MAIN;
terminal WORD_EXTENDS;
terminal WORD_THIS;
terminal WORD_NEW;
terminal WORD_LENGTH;
terminal WORD_PRINTLN;

/* tipos de dados */
terminal TYPE_INT;
terminal TYPE_BOOL;
terminal TYPE_STRING;

/* Condicionais */
terminal COND_IF;
terminal COND_ELSE;
terminal COND_WHILE;

/* Valores boleanos */

terminal BOOL_LITERAL;



/* operators: */
terminal OPC_PLUS, OPC_MINUS,OPC_EQUAL,OPC_NOT,OPC_MULT,OPC_AND,OPC_LT;

/* delimiters: */
terminal SEP_LPAREN, SEP_RPAREN, SEP_SEMICOLON,SEP_COMMA,SEP_DOT,SEP_LBRACE,SEP_RBRACE,SEP_LBRACK,SEP_RBRACK;

/* tokens with values: */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Assign AssignStatement;
nonterminal Return ReturnStatement;
nonterminal Exp Expression;
nonterminal Identifier Identifier;
nonterminal MainClass MainClass;


/* Precedence declarations */

precedence left OPC_PLUS;


/* Productions */

/* Goal 	::= 	MainClass ( ClassDeclaration )* <EOF> */
Program ::= MainClass:m ClassDecList:cd
            {: RESULT = new Program(m, cd ,mleft); :};
/* MainClass 	::= 	"class" Identifier "{" "public" "static" "void" "main" "(" "String" "[" "]" Identifier ")" "{" Statement "}" "}" */
MainClass ::= WORD_CLASS:c Identifier:id1 SEP_LBRACE WORD_PUBLIC WORD_STATIC WORD_VOID WORD_MAIN SEP_LPAREN TYPE_STRING SEP_LBRACK SEP_RBRACK
				Identifier:args SEP_RPAREN SEP_LBRACE Statement:stmt SEP_RBRACE SEP_RBRACE
				{: RESULT = new MainClass(id1, args, stmt, cleft); :}
/*ClassDeclaration 	::= 	"class" Identifier ( "extends" Identifier )? "{" ( VarDeclaration )* ( MethodDeclaration )* "}"*/

ClassDecl ::= WORD_CLASS:c Identifier:id SEP_LBRACE VarDeclarationList:v MethodDeclList:m SEP_RBRACE
				{: RESULT = new ClassDeclSimple(id, v, m, cleft); :}
			| WORD_CLASS:c Identifier:id WORD_EXTENDS Identifier:parent SEP_LBRACE VarDeclarationList:v MethodDeclList:m SEP_RBRACE
				{: RESULT = new ClassDeclExtends(id, parent, v, m , cleft); :}
			| WORD_CLASS:c Identifier:id SEP_LBRACE MethodDeclList:mdl SEP_RBRACE
				{: RESULT = new ClassDeclSimple(id, new VarDeclarationList(0), mdl, cleft); :}
			| WORD_CLASS:c Identifier:id WORD_EXTENDS Identifier:parent SEP_LBRACE MethodDeclList:mdl SEP_RBRACE
				{: RESULT = new ClassDeclExtends(id,parent, new VarDeclarationList(0), mdl, cleft); :}
			 
ClassDeclList ::=
            {: RESULT = new ClassDeclList(0); :}
        | ClassDecl:c ClassDeclList:l
            {: RESULT = l; l.addElement(c); :};

MethodDeclList ::=
            {: RESULT = new MethodDeclList(0); :}
        | MethodDecl:m MethodDeclList:l
            {: RESULT = l; l.addElement(m); :};

/*MethodDeclaration 	::= 	"public" Type Identifier "(" ( Type Identifier ( "," Type Identifier )* )? ")" "{" ( VarDeclaration )* ( Statement )* "return" Expression ";" "}"*/

MethodDecl ::= WORD_PUBLIC:p Type:t Identifier:id SEP_LPAREN FormalList:fl SEP_RPAREN SEP_LBRACE StatementList:sl WORD_RETURN Expression:expr SEP_SEMICOLON SEP_RBRACE
				{: RESULT = new MethodDecl(t, id, fl, new VarDeclList(0), sl, expr, pleft); :}
			| WORD_PUBLIC:p Type:t Identifier:id SEP_LPAREN FormarList:fl SEP_RPAREN SEP_LBRACE  VarDeclList:vdl StatementList:sl WORD_RETURN Expression:expr SEP_SEMICOLON SEP_RBRACE
				{: RESULT = new MethodDecl(t, id, fl, vdl, sl, expr, pleft); :}
				
/* ( Type Identifier ( "," Type Identifier )* )? */
FormalList ::= NonEmptyFL:fl
                 {: RESULT = fl; :}
	     | /* epsilon */
                 {: RESULT = new FormalList(0); :};


NonEmptyFL ::= Formal:f
                 {: FormalList flist = new FormalList(fleft);
                    flist.add(f);
                    RESULT = flist; :}
             | NonEmptyFL:fl SEP_COMMA Formal:f
                 {: fl.add(f); RESULT = fl; :};


VarDeclList ::= VarDecl:vd
                  {: VarDeclList vdl = new VarDeclList(vdleft);
                     vdl.add(vd);
                     RESULT = vdl; :}
              | VarDeclList:vdl VarDecl:vd
{: vdl.add(vd); RESULT = vdl; :};
	
/* Type Identier */

Formal ::= Type:type Identifier:id
	{: RESULT = new Formal(type, id, typeleft); :};

/* Type Identier ";" */

VarDecl ::= Type:type Identifier:id SEP_SEMICOLON
	{: RESULT = new VarDecl(type, id, typeleft); :};
	
/* Type */

Type ::= TYPE_INT:integer SEP_LBRACK SEP_RBRACK /* int [] */
	{: RESULT = new IntArrayType(integerleft); :}
	| TYPE_BOOLEAN:b /* boolean */
	{: RESULT = new BooleanType(bleft); :}
	| TYPE_INT:integer /* int */
	{: RESULT = new IntegerType(integerleft); :}
	| Identifier:id /* Identifier */
	{: new IdentifierType(id.toString(), idleft); :}

Statement ::= SEP_LBRACE:lb StatementList:s SEP_LBRACE
				{: RESULT = new Block(s, lbleft); :}
			| IfStatement:s
				{: RESULT = s; :}
			| WhileStatement:s
				{: Result = s; :}
			| DisplayStatement:s
				{: RESULT = s; :}
			| AssignStatement:s
				{: RESULT = s; :}
			| ArrayAssignStatement:s
				{: RESULT = s; :}
StatementList ::= NonEmptySL:sl
                    {: RESULT = sl; :}
		| /* epsilon */
                    {: RESULT = new StatementList(0); :};


NonEmptySL ::= Statement:s 
                 {: StatementList slist = new StatementList(sleft);
                    slist.add(s);
                    RESULT = slist; :}
             | NonEmptySL:sl Statement:s
                 {: sl.add(s); RESULT = sl; :}; 
				
AssignStatement ::= Identifier:id OPC_EQUAL Expression:expr SEP_SEMICOLON
                      {: RESULT = new Assign(id, expr, idleft); :};
WhileStatement ::= COND_WHILE:w SEP_LPAREN Expression:expr SEP_RPAREN Statement:s
                     {: RESULT = new While(expr, s, wleft); :};
IfStatement ::= COND_IF:i SEP_LPAREN Expression:expr SEP_RPAREN Statement:s1 COND_ELSE Statement:s2
                  {: RESULT = new If(expr, s1, s2, ileft); :};
ArrayAssignStatement ::= Identifier:id SEP_LBRACK Expression:expr1 SEP_RBRACK OPC_EQUAL Expression:expr2 SEP_SEMICOLON
             {: RESULT = new ArrayAssign(id, expr1, expr2, idleft); :};
DisplayStatement ::= WORD_PRINTLN:p Expression:expr SEP_SEMICOLON
                       {: RESULT = new Print(expr, pleft); :};
Expression ::= INTEGER_LITERAL:intl
                 {: RESULT = new IntegerLiteral(Integer.parseInt(intl), intlleft); :}
             | Expression:arg1 OPC_AND Expression:arg2
                 {: RESULT = new And(arg1, arg2, arg1left); :}  
             | Expression:arg1 OPC_LT Expression:arg2
                 {: RESULT = new LessThan(arg1, arg2, arg1left); :}  
             | Expression:arg1 PLUS Expression:arg2
                 {: RESULT = new Plus(arg1, arg2, arg1left); :}
             | Expression:arg1 OPC_MINUS Expression:arg2
                 {: RESULT = new Minus(arg1, arg2, arg1left); :}        
             | Expression:arg1 OPC_MULT Expression:arg2
                 {: RESULT = new Times(arg1, arg2, arg1left); :}   
             | Expression:arg1 SEP_LBRACK Expression:arg2 SEP_RBRACK
                 {: RESULT = new ArrayLookup(arg1, arg2, arg1left); :} 
             | Expression:arg SEP_DOT WORD_LENGTH
                 {: RESULT = new ArrayLength(arg, argleft); :}   
             |  Expression:expr1 SEP_DOT Identifier:id SEP_LPAREN ArgumentList:args SEP_RPAREN 
                  {: RESULT = new Call(expr1, id, args, expr1left); :} 
             | TRUE:t
                 {: RESULT = new True(tleft); :}
             | FALSE:f
                 {: RESULT = new False(fleft); :}
	           | IDENTIFIER:name
                 {: RESULT = new IdentifierExp(name, nameleft); :}
             | WORD_THIS:ths
                 {: RESULT = new This(thsleft); :}       
             | NEW:n INT SEP_LBRACK Expression:expr SEP_RBRACK
                 {: RESULT = new NewArray(expr, nleft); :} 
             | NEW:n Identifier:id SEP_LPAREN SEP_RPAREN
                 {: RESULT = new NewObject(id, nleft); :}
             | OPC_NOT Expression:expr 
                 {: RESULT = new Not(expr, exprleft); :} 
             | SEP_LPAREN Expression:expr SEP_RPAREN
                 {: RESULT = expr; :};
                 
ArgumentList ::= NonEmptyAL:ag
                   {: RESULT = ag; :}
	       | /* epsilon */
                   {: RESULT = new ExpList(0); :};


NonEmptyAL ::= Expression:expr
                 {: ExpList elist = new ExpList(exprleft);
                    elist.add(expr);
                    RESULT = elist; :}
             | NonEmptyAL:al COMMA Expression:expr 
 	         {: al.add(expr);
                    RESULT = al; :}; 

Identifier ::= IDENTIFIER:id
                 {: RESULT = new Identifier(id, idleft); :};